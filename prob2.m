#!/usr/bin/octave

%{

Project Euler Problem 2

Each new term in the Fibonacci sequence is generated by adding the previous 
two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms.

My solution is very simple.  It's iterative, meaning it's not exactly speedy,
but it does get the right answer, and it's easy to understand.  It goes 
through all Fibonacci numbers less than 4000000, and if they are even, adds
them to a running sum.
%}

% "Setup" info so that octave thinks this is a script and not a function file
printf('\n')
printf('Fibonacci Sequence Count\n')
printf('========================\n')

%{
The boring, somewhat naive but technically correct solution. It's iterative.
I'm a little disappointed in myself.
%}
function[retval] = fibo_iter(maxnum)
	su = 0;
	curr= 2;
	prev = 1;
	temp = 0;

	while(curr < maxnum)
		%if even, add to sum
 		if (mod(curr,2) == 0) 
 			su = su + curr;
 		endif

 		temp = curr;
 		curr = curr + prev;
 		prev = temp;
	endwhile

	printf('Sum = %d\n', su)

endfunction 

%{
The idea behind this is that the ratio between two numbers in the Fibonacci
sequence is the Golden Ratio, phi.  Additional insight is that every third 
number is even, which is easy enough to prove by induction.  Using that, the
ratio between every even number in the sequence is phi^3.  So we just 
mulitply by that each time and then we don't have to worry about checking all
the odd numbers cause we already know that we need to add this number.

Seeing as it does not iterate through all the Fibonnaci numbers, it would 
seem to be quite a bit faster.  However, floating-point operations aren't 
exactly the quickest, so I'm not sure how that would impact the overall
calculation. I would have liked to have done it without any branches, but the
nature of numerical math made that a little rough.
%}
function[retval] = fibo_phi(maxnum)

	phi = (1 + sqrt(5))/2;		%dat golden ratio
 	num = 2;
 	su = 0;
 	tmp = 0;
 	while(num <= maxnum)
  		su += num;
 		%Because of the nature of decimals, we will be getting a decimal out
 		%of the next calculation.  We'll have to make it an even integer, not
 		%just any integer, so it'll take some slightly inelegant work.
 		tmp = num * (phi^3);
 		tmp = floor(tmp);
 		if(mod(tmp,2) == 0)
 			num = tmp; 							%if already even, do nothing
 		else 
 			num = tmp +1;						%if odd, have to round up
 		endif
 	endwhile	
 	
 	printf('Sum = %d\n', su)
endfunction

% Now to the meat of the script, where stuff gets done
printf('Iterative solution:\t\t');
t0 = cputime();
fibo_iter(4000000); 	  %4000000 is the number given in the problem statement
t1 = cputime();
printf('Multiplicative solution:\t');
fibo_phi(4000000);
t2 = cputime();

printf('\n\n');

printf('The following are the times taken for each function to execute. They\n')
printf('were taken using the "cputime()" function, which is known to be     \n')
printf('somewhat inaccurate.  You will most likely see different times each \n')
printf('time you run this function. They are here for testing purposes only.\n')

printf('\n')

printf('Iterative solution time:\t%f\n', t1-t0)
printf('Multiplicative solution time:\t%f\n', t2-t1)